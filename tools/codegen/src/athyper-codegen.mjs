#!/usr/bin/env node

import { spawn } from "node:child_process";
import { mkdir, rm, cp, stat, readdir, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import path from "node:path";

const args = new Set(process.argv.slice(2));
const WATCH = args.has("--watch");

// Assumes this package lives at tools/codegen and script is executed from there.
const REPO_ROOT = path.resolve(path.dirname(new URL(import.meta.url).pathname), "../../..");

const DB_DIR = path.join(REPO_ROOT, "framework", "adapters", "db");
const DB_GEN_DIR = path.join(DB_DIR, "generated");
const CONTRACTS_GEN_DIR = path.join(REPO_ROOT, "packages", "contracts", "src", "generated", "prisma");

const ZOD_SRC = path.join(DB_GEN_DIR, "zod");
const KYSELY_SRC = path.join(DB_GEN_DIR, "kysely");

const ZOD_DST = path.join(CONTRACTS_GEN_DIR, "zod");
const KYSELY_DST = path.join(CONTRACTS_GEN_DIR, "kysely");

function run(cmd, cmdArgs, opts = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(cmd, cmdArgs, { stdio: "inherit", shell: process.platform === "win32", ...opts });
    child.on("exit", (code) => {
      if (code === 0) resolve();
      else reject(new Error(`${cmd} ${cmdArgs.join(" ")} failed with code ${code}`));
    });
  });
}

async function ensureDir(p) {
  await mkdir(p, { recursive: true });
}

async function safeRm(p) {
  if (existsSync(p)) await rm(p, { recursive: true, force: true });
}

async function dirHasFiles(p) {
  try {
    const s = await stat(p);
    if (!s.isDirectory()) return false;
    const items = await readdir(p);
    return items.length > 0;
  } catch {
    return false;
  }
}

async function syncFolder(src, dst) {
  if (!(await dirHasFiles(src))) {
    throw new Error(`Expected generated folder missing or empty: ${src}\nDid prisma generators run and output to the expected path?`);
  }
  await safeRm(dst);
  await ensureDir(path.dirname(dst));
  await cp(src, dst, { recursive: true });
}

async function writeEntryPoints() {
  // Provide stable entrypoints for generated code.
  // These files are small and can be committed safely.
  // Generated prisma artifacts live under src/generated/prisma/ so they are
  // inside tsconfig rootDir ("src") and DTS generation works correctly.
  const genRoot = path.join(REPO_ROOT, "packages", "contracts", "src", "generated");
  await ensureDir(path.join(genRoot, "prisma"));

  // Zod entrypoint
  const zodIndex = path.join(genRoot, "prisma", "zod", "index.ts");
  if (!existsSync(zodIndex)) {
    // Many generators already create an index.ts; if not, create a minimal one.
    // This is intentionally conservative.
    await writeFile(
      zodIndex,
      `// Auto-created by athyper-codegen (fallback)\n// If your generator already emits an index.ts, this file may be overwritten.\n\nexport {};\n`,
      "utf8"
    );
  }

  // Kysely entrypoint
  const kyselyIndex = path.join(genRoot, "prisma", "kysely", "index.ts");
  if (!existsSync(kyselyIndex)) {
    await writeFile(
      kyselyIndex,
      `// Auto-created by athyper-codegen (fallback)\n// Expected: generator emits DB interface/types used by Kysely.\n\nexport {};\n`,
      "utf8"
    );
  }

  // Contracts side re-export
  const contractsGenIndex = path.join(genRoot, "index.ts");
  await ensureDir(path.dirname(contractsGenIndex));
  await writeFile(
    contractsGenIndex,
    `// Auto-generated by athyper-codegen\nexport * as prismaZod from "./prisma/zod/index.js";\nexport * as prismaKysely from "./prisma/kysely/index.js";\n`,
    "utf8"
  );
}

async function mainOnce() {
  console.log("\n[Athyper] Running prisma generate...");
  await run("pnpm", ["-C", DB_DIR, "prisma", "generate"]);

  console.log("\n[Athyper] Sync generated artifacts into contracts...");
  await ensureDir(CONTRACTS_GEN_DIR);
  await syncFolder(ZOD_SRC, ZOD_DST);
  await syncFolder(KYSELY_SRC, KYSELY_DST);

  console.log("\n[Athyper] Writing stable entrypoints...");
  await writeEntryPoints();

  console.log("\n[Athyper] Done: contracts generated artifacts updated.");
}

if (!WATCH) {
  await mainOnce();
} else {
  // Minimal watch: re-run on schema.prisma changes.
  // Use node built-in fs watch recursively where supported.
  const schemaPath = path.join(DB_DIR, "prisma", "schema.prisma");
  console.log(`[Athyper] Watch mode: ${schemaPath}`);
  await mainOnce();
  const { watch } = await import("node:fs");
  let timer = null;
  watch(schemaPath, () => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      mainOnce().catch((e) => console.error(e));
    }, 250);
  });
}
